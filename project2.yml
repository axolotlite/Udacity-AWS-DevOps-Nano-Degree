Description: >
  Udacity cloud devops nano degree, second project.
#on public routing, one can make a subnet public by adding it to the main internet gateway with a route "0.0.0.0/0"
#this means the subnet has access to the internet
#the same logic can be be applied to other subnets, to allow commumincation between them you must add a NATgateway to the subnets route table
#on nats, they're used in private subnets to allow them external access while preventing external services from initiating a connection with whomever is in the private subnet
Parameters:
  BastionSSHKey:
    Description: The name of the key used for the bastion host
    Type: String
  ApplicationSSHKey:
    Description: The name of the key used for the Application, it's left default once its no longer needed
    Type: String
    Default: ''
Mappings:
  SubnetConfig:
    VPC:
      CIDR: "10.0.0.0/16"
    Public0:
      CIDR: "10.0.0.0/24"
    Public1:
      CIDR: "10.0.1.0/24"
    Private0:
      CIDR: "10.0.2.0/24"
    Private1:
      CIDR: "10.0.3.0/24"
Resources:
#The main VPC containing everything()
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !FindInMap ["SubnetConfig", "VPC", "CIDR"]
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-VPC"
#The 4 subnets, 2 public containing natgateways connecting the 2 private subnets
  #private subnets
    #These private subnets are not given a public IP on launch to prevent unwanted access
  PrivateSubnet0:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !FindInMap ["SubnetConfig", "Private0", "CIDR"]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Private-Subnet-0"
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !FindInMap ["SubnetConfig", "Private1", "CIDR"]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Private-Subnet-1"
  #public subnet
    #These ones are not given public ips because they'll be given elastic IPs.
  PublicSubnet0:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, !GetAZs '']
      VpcId: !Ref VPC
      CidrBlock: !FindInMap ["SubnetConfig", "Public0", "CIDR"]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Public-Subnet-0"
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, !GetAZs '']
      VpcId: !Ref VPC
      CidrBlock: !FindInMap ["SubnetConfig", "Public1", "CIDR"]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Public-Subnet-1"
#Gateways then their attachments
  #The main internet gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-InternetGateway"
  #its attachment to the VPC, i don't think i need to name the attachment
  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC
  #nat gateways and their respective subnets and elastic ips
    #natgateways are only applicable for public subnets
  PublicNATGateway0:
    Type: "AWS::EC2::NatGateway"
    Properties:
      SubnetId: !Ref "PublicSubnet0"
      AllocationId: !GetAtt [ "NATElasticIP0", "AllocationId" ]
  PublicNATGateway1:
    Type: "AWS::EC2::NatGateway"
    Properties:
      SubnetId: !Ref "PublicSubnet1"
      AllocationId: !GetAtt [ "NATElasticIP1", "AllocationId" ]
#Routetables
  #The default/main routetable, all traffic goes through here.
  #it also routes it through the internet gateway.
  MainRouteTable:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Main-Routetable"
  #The private route table should allow routes to:
    #internet for application updates
    #public nat for the loadbalancer forwarding
  PrivateRouteTable0:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId: !Ref "VPC"
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Private-Route-Table-0'
  PrivateRouteTable1:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId: !Ref "VPC"
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Private-Route-Table-1'
#The association between the routetables and their respective subnets
  #The public subnets are associated with the main route, since they have unlimited access to the internet
  PublicSubnet0MainRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref MainRouteTable
      SubnetId: !Ref PublicSubnet0
  PublicSubnet1MainRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref MainRouteTable
      SubnetId: !Ref PublicSubnet1
  #The private subnet will be associated with their respective route tables.
  PrivateSubnet0RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable0
      SubnetId: !Ref PrivateSubnet0
  #subnet route association of private subnet 1 and its route table
  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      SubnetId: !Ref PrivateSubnet1
#Routes and theis association to the route table
  #The route into the internet, it allows traffic anywhere in the internet(0.0.0.0/0)
  InternetRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref MainRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
  #private routes to everything on the public subnet and by proxy: the internet
  PrivateRouteNatGateway0:
    Type: "AWS::EC2::Route"
    Properties:
      RouteTableId: !Ref "PrivateRouteTable0"
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref "PublicNATGateway0"
  PrivateRouteNatGateway1:
    Type: "AWS::EC2::Route"
    Properties:
      RouteTableId: !Ref "PrivateRouteTable1"
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref "PublicNATGateway1"
#Autoscaling and its target group
  #This launches ec2 instances in their respective subnets
  UbuntuAutoscalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      LaunchConfigurationName: !Ref LaunchHTTPServerUbuntu
      MinSize: '4'
      MaxSize: '6'
      VPCZoneIdentifier: [!Ref PrivateSubnet0, !Ref PrivateSubnet1]
      TargetGroupARNs: [!Ref HTTPTargetGroup]
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Ubuntu-HTTP-Autoscaling-Group'
  HTTPTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: HTTPTarget
      Port: 80
      Protocol: HTTP
      HealthCheckIntervalSeconds: 10
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 8
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 5
      VpcId: !Ref VPC
#Loadbalancer and its related settings
  #the load balancer (application type) and its related subnets
  ElasticLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: "application"
      SecurityGroups: [!Ref LoadBalancerSecurityGroup]
      Subnets: [!Ref PublicSubnet0, !Ref PublicSubnet1]
      IpAddressType: "ipv4"
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Application-Loadbalancer'
  HTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
        DefaultActions:
          - Type: forward
            TargetGroupArn: !Ref HTTPTargetGroup
        LoadBalancerArn: !Ref ElasticLoadBalancer
        Protocol: HTTP
        Port: 80
  HTTPListenerRule:
      Type: AWS::ElasticLoadBalancingV2::ListenerRule
      Properties:
          Actions:
          -   Type: forward
              TargetGroupArn: !Ref HTTPTargetGroup
          Conditions:
          -   Field: path-pattern
              Values: [/]
          ListenerArn: !Ref HTTPListener
          Priority: 1 
#Security Groups
  #The loadbalancer security group should allow incoming connections at port 80(http), the load balancer should already ahve access to the internet so no need to specify egress
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          CidrIp: 0.0.0.0/0
          FromPort: 80
          ToPort: 80
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Loadbalancer-Security-Group'
  #This allows us to ssh into our bastion host
  BastionSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Bastion-Security-Group'
  #This is the security group responsible for the load balancer to communicate with this application
  #the ssh is currently open for everyone just for debugging reasons, it will late be locked down only for the bastion host
  ApplicationSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          SourceSecurityGroupId: !Ref BastionSecurityGroup
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Application-HTTP-BastionSSH-Security-Group'
#Launch Configuration
  LaunchHTTPServerUbuntu: 
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          apt-get update -y
          apt-get install unzip awscli -y
          apt-get install apache2 -y
          systemctl start apache2.service
          echo -e "Udacity Project 2: Electric Boogaloo\nCreated on $(date)" > /var/www/html/index.html
      ImageId: ami-0729e439b6769d6ab
      KeyName: !Ref ApplicationSSHKey
      SecurityGroups: [!Ref ApplicationSecurityGroup]
      InstanceType: 't3.small'
      Tags:
          - Key: "Name"
            Value: !Sub '${AWS::StackName}-Ubuntu-HTTP-Launch-Configs'
#Elastic Ips
  NATElasticIP0:
    Type: "AWS::EC2::EIP"
    Properties:
      Domain: "vpc"
  NATElasticIP1:
    Type: "AWS::EC2::EIP"
    Properties:
      Domain: "vpc"
  BastionElasticIP:
    Type: "AWS::EC2::EIP"
    Properties:
      Domain: "vpc"
#Ec2 instances
  BastionInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: 'ami-0cff7528ff583bf9a'
      InstanceType: 't2.micro'
      KeyName: !Ref BastionSSHKey
      SubnetId: !Ref PublicSubnet0
      SecurityGroupIds: [!Ref BastionSecurityGroup]
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Bastion-Instance'
  BastionEIPAssocation:
    Type: AWS::EC2::EIPAssociation
    Properties: 
      EIP: !Ref BastionElasticIP
      InstanceId: !Ref BastionInstance
Outputs:
  LoadbalancerURL:
    Description: URL of the load balancer for quick access
    Value: !Sub "http://${ElasticLoadBalancer.DNSName}"
    Export:
      Name: !Sub ${AWS::StackName}-LoadBalancer-URL
  BastionPublicIp:
    Description: 'Bastion public ip'
    Value: !Sub '${BastionInstance.PublicIp}'
    Export:
      Name: BastionPublicIp
